
# Task 1
Scroll to the bottom of Main.hs, where you will find an incomplete definition of the function resolve_on.

resolve_on is meant to take a Literal and two Clauses as input and return the new Clause generated by resolving the two input clauses on this literal. We assume that the literal occurs in the first input clause, and its negation occurs in the second. The function should ensure the returned clause is sorted and has no duplicate literals.

For example:

Main> resolve_on (Pos 'A') [Pos 'A', Neg 'B'] [Neg 'A']

[Neg 'B']

Main> resolve_on (Neg 'B') [Pos 'A', Neg 'B'] [Pos 'A', Pos 'B', Pos 'C']

[Pos 'A', Pos 'C']

Complete this function.

# Task 2
Next we'll put the resolve_on function to use within the algorithm. Begin this problem by copying over your successful solution to the previous problem.

Above the definition of resolve_on, you'll find an incomplete definition of the function resolvents.

resolvents is meant to take two Clauses as input and return a list of all clauses which may be generated by resolving these two clauses together, on any of their literals. Depending on the combination of literals in the two clauses, there may be zero, one or many such clauses. The returned list may contain these clauses in any order.

For example:

Main> resolvents [Pos 'A', Neg 'B'] [Neg 'A']
[[Neg 'B']]

Main> resolvents [Pos 'A', Neg 'B'] [Pos 'B', Pos 'C', Neg 'A']
[[Pos 'A', Pos 'C', Neg 'A'], [Pos 'B', Pos 'C', Neg 'B']]

Main> resolvents [Pos 'A', Pos 'B'] [Pos 'A', Neg 'C']
[]

# Task 3
Now that you have finished these two tasks, you have a working resolution algorithm and you can use the unsatisfiable function to test the satisfiability of your formulas.

However, often we would like to use the resolution technique to prove not just the satisfiability or unsatisfiability of a single propositional formula, but logical consequence relationships between two propositional formulas.

Your final task for this section of the worksheet is to implement an additional function inside Main.hs to do just that. This function should be pretty simple, and should make use of the existing unsatisfiable function. For this to work, you'll need to copy over your solutions from the previous problems once again.

Write a function entails which takes two Formulas f and g and returns True if and only if formula g is a logical consequence of f (in which case, we would say that f entails g). Don't forget a type signature!

For example:

Main> entails [[Pos 'Q', Neg 'P'], [Pos 'P']] [[Pos 'Q']]
True

Main> entails [[Pos 'Q', Neg 'P']] [[Pos 'P', Neg 'Q']]
False